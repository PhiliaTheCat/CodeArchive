#ifndef __INCLUDED_HIGH_PRECISION__
#define __INCLUDED_HIGH_PRECISION__

#include <cstdint>
#include <ostream>
#include <istream>
#include <iomanip>
#include <cmath>

namespace ptc
{
    static const uint32_t __HIGH_PRECISION_ARR_SIZE = 1024;

    template<std::uint32_t Unit = std::uint32_t(1e4)>
    class High_Precision;

    template<std::uint32_t Unit>
    std::istream &operator >>(std::istream &lhs, High_Precision<Unit> &rhs);
    template<std::uint32_t Unit>
    std::ostream &operator <<(std::ostream &lhs, const High_Precision<Unit> &rhs);

    template<std::uint32_t Unit>
    class High_Precision
    {
        private:
        bool sign;
        uint32_t arr[__HIGH_PRECISION_ARR_SIZE];
        uint16_t n;

        public:
        High_Precision(const int64_t &src = 0)
        : arr{}
        {
            uint64_t p;
            if (src >= 0)
            {
                sign = false;
                p = src;
            }
            else 
            {
                sign = true;
                p = -src;
            }

            int i = 0;
            while (p > 0)
            {
                arr[i] = p % 1000;
                p /= 1000;
                i += 1;
            }

            n = i;
        }

        inline High_Precision(const High_Precision &src)
        : sign(src.sign), n(src.n), arr{}
        {
            for (int i = 0; i < n; i += 1)
                arr[i] = src.arr[i];
        }

        inline High_Precision &operator =(const High_Precision &src)
        {
            if (&src == *this)
                return *this;

            sign = src.sign;
            n = src.n;
            for (int i = 0; i < n; i += 1)
                arr[i] = src.arr[i];

            return *this;
        }

        friend std::istream &operator >><Unit>(std::istream &lhs, High_Precision<Unit> &rhs);
        inline friend std::ostream &operator <<<Unit>(std::ostream &lhs, const High_Precision<Unit> &rhs);

        High_Precision operator +(const High_Precision &rhs) const noexcept(false)
        {
            High_Precision res;
            int p;

            if (n >= rhs.n)
                p = rhs.n;
            else 
                p = n;
            
            if (sign == rhs.sign)
                res.sign = sign;
            else 
                throw "Undefined behaviour!";
            
            bool flag = 0;
            for (int i = 0; i < p; i += 1)
            {
                res.arr[i] = arr[i] + rhs.arr[i] + flag;
                if (res.arr[i] >= Unit)
                {
                    res.arr[i] -= Unit;
                    flag = true;
                }
                else 
                    flag = false;
            }

            if (n >= rhs.n)
            {
                for (int i = p; i < n; i += 1)
                {
                    res.arr[i] = arr[i] + flag;
                    if (res.arr[i] >= Unit)
                    {
                        res.arr[i] -= Unit;
                        flag = true;
                    }
                    else 
                        flag = false;
                }
            }
            else 
            {
                for (int i = p; i < lhs.n; i += 1)
                {
                    res.arr[i] = lhs.arr[i] + flag;
                    if (res.arr[i] >= Unit)
                    {
                        res.arr[i] -= Unit;
                        flag = true;
                    }
                    else 
                        flag = false;
                }
            }

            if (flag)
            {
                if (n >= rhs.n)
                {
                    res.arr[n] = 1;
                    res.n = n + 1;
                }
                else
                {
                    res.arr[rhs.n] = 1;
                    res.n = rhs.n + 1;
                }
            }
            else 
            {
                if (n >= rhs.n)
                    res.n = n;
                else 
                    res.n = rhs.n;
            }

            return res;
        }
    };

    template<std::uint32_t Unit>
    std::istream &operator >>(std::istream &lhs, High_Precision<Unit> &rhs)
    {
        char buff[4 * __HIGH_PRECISION_ARR_SIZE + 1];
        lhs >> buff;

        int i = 0;
        while (buff[i] != 0)
            i += 1;
        
        if (buff[0] == '-')
            rhs.sign = true;
        else if (buff[0] != '-')
            rhs.sign = false;
            

        int count = 0;
        int p = 1;
        int t = 0;
        i -= 1;
        while (i > -1)
        {
            if (buff[i] >= '0' && buff[i] <= '9')
            {
                t += (buff[i] - '0') * p;
                p *= 10;
                count += 1;
                if (count % int(log10(Unit)) == 0 || i == 1 && buff[0] == '-' || i == 0)
                {
                    rhs.arr[(count - 1) / int(log10(Unit))] = t;
                    t = 0;
                    p = 1;
                }
            }
            i -= 1;
        }

        rhs.n = (count - 1) / int(log10(Unit)) + 1;

        return lhs;
    }

    template<std::uint32_t Unit>
    std::ostream &operator <<(std::ostream &lhs, const High_Precision<Unit> &rhs)
    {
        if (rhs.sign)
            cout << '-';

        cout << rhs.arr[rhs.n - 1];
        for (int i = rhs.n - 2; i > -1; i -= 1)
            cout << setw(int(log10(Unit))) << setfill('0') << rhs.arr[i];
        
        return lhs;
    }
}

#endif
