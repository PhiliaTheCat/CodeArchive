#ifndef __INCLUDED_HIGH_PRECISION__
#define __INCLUDED_HIGH_PRECISION__

#include <cstdint>
#include <bitset>
#include <ostream>

namespace ptc
{
    template<std::uint16_t __LENGTH = 1024>
    class High_Precision
    {
        private:
        std::bitset<__LENGTH> __bit;

        public:
        inline High_Precision(const std::int64_t &src = 0)
        : __bit(src)
        {
            if (src < 0)
            {
                for (int i = 64; i < __LENGTH; i += 1)
                    __bit[i] = 1;
            }
        }

        inline High_Precision(const High_Precision &src)
        : __bit(src.__bit)
        {}

        inline High_Precision(High_Precision &&src)
        : __bit(src.__bit)
        {}

        inline High_Precision &operator =(const High_Precision &rhs)
        {
            __bit = rhs.bit;
            return *this;
        }

        inline High_Precision &operator =(High_Precision &&rhs)
        {
            __bit = rhs.__bit;
            return *this;
        }

        friend inline bool operator ==(const High_Precision &lhs, const High_Precision &rhs)
        {
            return lhs.__bit == rhs.__bit;
        }

        friend inline High_Precision operator +(const High_Precision &rhs)
        {
            return rhs;
        }

        friend High_Precision operator +(const High_Precision &lhs, const High_Precision &rhs)
        {
            High_Precision res;
            bool carry = false;
            for (int i = 0; i < __LENGTH; i += 1)
            {
                res.__bit[i] = lhs.__bit[i] ^ rhs.__bit[i] ^ carry;
                carry = lhs.__bit[i] & rhs.__bit[i] |
                        lhs.__bit[i] & carry |
                        rhs.__bit[i] & carry;
            }
            return res;
        }
    };
}

#endif
